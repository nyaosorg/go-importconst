package main

import (
	"bufio"
	"errors"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"strings"
	"unicode"
)

var (
	flagCSrc       = flag.String("csrc", "zconst.cpp", "c-source filename used temporally")
	flagCc         = flag.String("cc", "gcc", "c compiler command")
	flagGoSrc      = flag.String("o", "zconst.go", "go-source-filename to output constants")
	flagClean      = flag.Bool("c", false, "clean output")
	flagDebug      = flag.Bool("d", false, "debug flag")
	flagNofmt      = flag.Bool("nofmt", false, "do not execute go fmt (for debug)")
	flagPrefix     = flag.String("prefix", "", "append word to symbol as prefix")
	flagUpperCamel = flag.Bool("uppercamel", false, "AAA_BBB_CCC to AaaBbbCcc")
	flagLowerCamel = flag.Bool("lowercamel", false, "AAA_BBB_CCC to aaaBbbCcc")
)

func snakeToCamel(s string, conv func(rune) rune) string {
	var buffer strings.Builder
	buffer.Grow(len(s))

	for _, c := range s {
		if c == '_' {
			conv = unicode.ToUpper
			continue
		}
		buffer.WriteRune(conv(c))
		conv = unicode.ToLower
	}
	return buffer.String()
}

func snakeToUpperCamel(s string) string {
	return snakeToCamel(s, unicode.ToUpper)
}

func snakeToLowerCamel(s string) string {
	return snakeToCamel(s, unicode.ToLower)
}

func makeCSource(packageName, csrcname string, headers []string, vars []string, filters []func(string) string) error {
	fd, err := os.Create(csrcname)
	if err != nil {
		return err
	}
	defer fd.Close()

	for _, header1 := range headers {
		fmt.Fprintf(fd, "#include %s\n", header1)
	}
	fmt.Fprint(fd, `
void p(FILE *w,const char *name,const char *s){
	fprintf(w,"const %s = \"%s\"\n",name,s);
}
void p(FILE *w,const char *name,int n){
	fprintf(w,"const %s = %d\n",name,n);
}
void p(FILE *w,const char *name,long n){
	fprintf(w,"const %s = %ld\n",name,n);
}
void p(FILE *w,const char *name,unsigned long n){
	fprintf(w,"const %s = %lu\n",name,n);
}
void p(FILE *w,const char *name,double n){
	fprintf(w,"const %s = %lf\n",name,n);
}

int main(int argc,char **argv)
{
`)
	fmt.Fprintln(fd, `    if ( argc < 2 ){ return 1; }`)
	fmt.Fprintln(fd, `    FILE *w=fopen(argv[1],"wb");`)
	fmt.Fprintln(fd, `    if ( w == NULL ){ return 2; }`)
	fmt.Fprintln(fd, `    fprintf(w,"package `+packageName+`\n\n");`)
	fmt.Fprintln(fd, `    fprintf(w,"// Code generated by go-importconst DO NOT EDIT.\n");`)

	for _, orgName := range vars {
		newName := orgName
		for _, f := range filters {
			newName = f(newName)
		}
		fmt.Fprintf(fd, "    p(w,\"%s\",%s);\n", newName, orgName)
	}
	fmt.Fprintln(fd, "    fclose(w);")
	fmt.Fprintln(fd, "    return 0;")
	fmt.Fprintln(fd, "}")
	return nil
}

func compile(compiler, csource string) error {
	var cc exec.Cmd
	cc.Args = []string{
		compiler,
		csource,
	}
	compilerFullPath, err := exec.LookPath(compiler)
	if err != nil {
		return err
	}
	cc.Path = compilerFullPath
	cc.Stdout = os.Stdout
	cc.Stderr = os.Stderr
	fmt.Fprintln(os.Stderr, compilerFullPath, csource)
	return cc.Run()
}

func nameOfExecutable() string {
	if runtime.GOOS == "windows" {
		return ".\\a.exe"
	} else {
		return "./a.out"
	}
}

func callAOut(aoutPath, gosrc string) error {
	cmd := exec.Cmd{
		Args:   []string{aoutPath, gosrc},
		Path:   aoutPath,
		Stdout: os.Stdout,
		Stderr: os.Stderr,
	}
	fmt.Fprintln(os.Stderr, aoutPath, gosrc)
	return cmd.Run()
}

func gofmt(gosource string) error {
	var gofmt exec.Cmd
	gofmt.Args = []string{
		"go",
		"fmt",
		gosource,
	}
	fn, err := exec.LookPath("go")
	if err != nil {
		return err
	}
	gofmt.Path = fn
	gofmt.Stdout = os.Stdout
	gofmt.Stderr = os.Stderr
	fmt.Fprintln(os.Stderr, fn, "fmt", gosource)
	return gofmt.Run()
}

func readSymbols(gofile string, lnum int) ([]string, error) {
	fd, err := os.Open(gofile)
	if err != nil {
		return nil, err
	}
	sc := bufio.NewScanner(fd)
	var tokens []string
	for sc.Scan() {
		lnum--
		if lnum >= 0 {
			continue
		}
		text := sc.Text()
		if !strings.HasPrefix(text, "//") {
			break
		}
		fields := strings.Fields(text[2:])
		if len(fields) <= 0 {
			break
		}
		for _, arg1 := range fields {
			tokens = append(tokens, arg1)
		}
	}
	return tokens, nil
}

func remove(fn string) {
	fmt.Fprintln(os.Stderr, "rm", fn)
	os.Remove(fn)
}

func mains() error {
	if *flagClean {
		remove(*flagCSrc)
		remove(nameOfExecutable())
		remove(*flagGoSrc)
		return nil
	}
	packageName, ok := os.LookupEnv("GOPACKAGE")
	if !ok {
		return errors.New("$GOPACKAGE is not defined. Use `go generate`")
	}
	gofile, ok := os.LookupEnv("GOFILE")
	if !ok {
		return errors.New("$GOFILE is not defined. Use `go generate`")
	}
	goline, ok := os.LookupEnv("GOLINE")
	if !ok {
		return errors.New("$GOLINE is not defined. Use `go generate`")
	}
	lnum, err := strconv.Atoi(goline)
	if err != nil {
		return fmt.Errorf("$GOLINE: %s", err.Error())
	}
	goParams, err := readSymbols(gofile, lnum)
	if err != nil {
		return err
	}
	headers := []string{"<cstdio>"}
	vars := make([]string, 0)
	for _, s := range goParams {
		if len(s) > 0 && s[0] == '<' {
			headers = append(headers, s)
		} else if strings.HasSuffix(s, ".h") {
			headers = append(headers, fmt.Sprintf(`"%s"`, s))
		} else {
			vars = append(vars, s)
		}
	}
	filters := make([]func(string) string, 0, 3)
	if *flagLowerCamel {
		filters = append(filters, snakeToLowerCamel)
	}
	if *flagUpperCamel {
		filters = append(filters, snakeToUpperCamel)
	}
	if *flagPrefix != "" {
		filters = append(filters, func(s string) string {
			return *flagPrefix + s
		})
	}
	if err := makeCSource(packageName, *flagCSrc, headers, vars, filters); err != nil {
		return err
	}
	if !*flagDebug {
		defer remove(*flagCSrc)
	}
	if err = compile(*flagCc, *flagCSrc); err != nil {
		return err
	}
	aoutPath := nameOfExecutable()
	if err := callAOut(aoutPath, *flagGoSrc); err != nil {
		return err
	}
	remove(aoutPath)

	if !*flagNofmt {
		if err := gofmt(*flagGoSrc); err != nil {
			return err
		}
	}
	return nil
}

func main() {
	flag.Parse()
	if err := mains(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		return
	}
}
